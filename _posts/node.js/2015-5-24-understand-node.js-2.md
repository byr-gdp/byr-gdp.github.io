---
layout: post
title: 《深入浅出node.js》笔记（二）
category: node
tags: 
description: 《深入浅出node.js》笔记（二）
---

# 第二章 模块机制

初读这部分内容感觉很吃力，尤其是模块编写、模块编译等部分，对于这部分内容暂时不整理。发布包流程尚未实践，亦未整理，但心中有一定数。在今后学习实践过程中遇到相关问题后再来回顾、整理、总结知识体系。


###　CommonJS规范  

CommonJS规范为JavaScript制定了一个美好的愿景——希望JavaScript能够在任何地方运行。  
CommonJS对模块的定义十分简单，主要分为**模块引用、模块定义和模块标识**三个部分。  
CommonJS构建的这套模块导出和引入机制使得用户完全不必考虑变量污染，命名空间等方案与之相比相形见绌。

### Node的模块实现  
在Node中引入模块，需要经历如下3个步骤：

	1. 路径分析
	2. 文件定位
	3. 编译执行

在Node中，模块分为两类：一类是Node提供的模块，称为**核心模块**，另一类是用户编写的模块，称为**文件模块**。

### 核心模块  
核心模块的引入流程：要经历C/C++层面的内建模块定义、（JavaScript）核心模块的定义和引入以及（JavaScript）文件模块层面的引入。但是对于用户而言，require()十分简洁、友好

### C/C++扩展模块

### 模块调用栈  
核心模块：JavaScript模块 + C/C++内建模块  
文件模块：JavaScript模块 + C/C++扩展模块

### 包与NPM  
CommonJS包规范是理论，NPM是其中的一种实践。NPM之于Node，相当于gem之于Ruby，pear之于PHP。  
安装依赖包：

1. 全局模式安装  
	如执行`npm install express -g`。需要注意的是，全局模式并不是将一个模块包安装为一个全局包的意思，它并不意味着可以从任何地方通过require()来引用到它。事实上，通过全局模式安装的所有模块包都被安装进了一个统一地目录下。
2. 从本地安装  
3. 从非官方源安装

分析包：  
在使用NPM过程中，或许你不能确认当前目录下能否通过require()顺利引入想要的包，这时可以执行`npm ls`分析包。该命令可以为你分析出当前路径下能够通过模块路径找到的所有包，并生成依赖树。


###　前后端共用模块

AMD规范是CommonJS模块规范的一个延伸。 CMD规范由国内的玉伯提出，与AMD规范的主要区别在于定义模块和依赖引入的部分。